// vim: expandtab:ts=4:sw=4
/*
 * Copyright 2016 Carsten Klein
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import {extractFormalParameterList} from '../utils';
import {assertFunctionType, assertDecoratingType} from './assertions';


/**
 * Factory for creating decorated classes.
 *
 * This provides the user with the means to create a conformant sub class of
 * the decorated class that will call the specified ctor during instance
 * construction.
 *
 * The so created class will have the same name and the constructor will
 * have the same signature as the decorated class.
 *
 * Please note that this does not provide for any means to bind additional
 * methods a/o properties to the class.
 *
 * @param {TargetType} target - the target
 * @param {DecoratingCtorType} ctor - the decorating ctor
 * @param {Boolean} bound - true whether ctor is already bound
 * @returns {Class} - the decorated class
 */
export default function decoratedClassFactory(target, ctor, bound = false)
{
    assertFunctionType('target', target);

    if (!target.name)
    {
        throw new TypeError('target must be a named function');
    }

    assertFunctionType('ctor', ctor);
    assertDecoratingType('ctor', ctor, 'DecoratingCtorType', bound);

    const formalParameterList = extractFormalParameterList(target);

    /*eslint no-new-func:0*/
    const result = new Function(
        ['getSuper', 'classCallCheck', 'ctor', 'bound'],
        `
        function ${target.name}(${formalParameterList})
        {
            classCallCheck(this, ${target.name});
            var base = getSuper(
                Object.getPrototypeOf(${target.name}.prototype),
                'constructor', this
            );
            var args = Array.prototype.slice.apply(arguments);
            if (bound)
            {
                ctor(this, base, args);
            }
            else
            {
                ctor.apply(this, [base, args]);
            }
        };

        return ${target.name};
        `
    )(getSuper, classCallCheck, ctor, bound);

    inherit(result, target);

    return result;
}


/*
 * The following helper functions were adapted from source that was
 * generated by the babel transpiler.
 */

/**
 * @private
 */
/* istanbul ignore next */
function getSuper(proto, property, receiver)
{
    let result;

    let parent = proto || Function.prototype;
    while (parent)
    {
        let desc = Object.getOwnPropertyDescriptor(parent, property);
        if (desc === undefined)
        {
            parent = Object.getPrototypeOf(parent);
        }
        else
        {
            if ('value' in desc)
            {
                result = desc.value;
            }
            else if (desc.get)
            {
                result = desc.get.call(receiver);
            }
            break;
        }
    }

    return result;
}


/**
 * @private
 */
/* istanbul ignore next */
function classCallCheck(instance, constructor)
{
    if (!(instance instanceof constructor))
    {
        throw new TypeError('Cannot call a class as a function');
    }
}


/**
 * @private
 */
/* istanbul ignore next */
function inherit(subClass, superClass)
{
    if (typeof superClass !== 'function' && superClass !== null)
    {
        throw new TypeError(
            'Super expression must either be null or a function, '
            + `not ${typeof superClass}`
        );
    }

    subClass.prototype = Object.create(
        superClass && superClass.prototype,
        {
            constructor:
            {
                value: subClass, enumerable: false,
                writable: true, configurable: true
            }
        }
    );

    if (superClass)
    {
        if (Object.setPrototypeOf)
        {
            Object.setPrototypeOf(subClass, superClass);
        }
        else
        {
            subClass.__proto__ = superClass;
        }
    }
}

